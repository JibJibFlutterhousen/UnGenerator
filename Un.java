public class Un{
	int n;
	int[] Un_as_a_set;
	int size_of_Un;
	boolean is_cyclic;
	Subgroup[] subgroups_generated_by_elements;
	int[] subgroup_generators;
	int num_distinct_subgroups;


	public Un(int the_n){
		/*
			start by allocating space for Un, assuming that |U(n)| = n
		*/
		this.n = the_n;
		this.Un_as_a_set = new int[this.n];
		for(int i = 0; i < this.n; i++){
			this.Un_as_a_set[i] = -1;
		}
		/*
			populate the allocated array with the true values for U(n), keeping track of |U(n)| in counter
		*/
		int counter = 0;
		for(int i = 0; i < this.n; i++){
			if(Un_Generator_Utilities.gcd(i,this.n) == 1){
				this.Un_as_a_set[counter++] = i;
			}
		}
		/*
			set size_of_Un and trim the assumed size of the U(n) array by copying it into a temp array, and then setting it to the newly created temp array
		*/
		this.size_of_Un = counter;
		int temp[] = new int[this.size_of_Un];
		for(int i = 0; i < this.size_of_Un; i++){
			temp[i] = this.Un_as_a_set[i];
		}
		this.Un_as_a_set = new int[this.size_of_Un];
		for(int i = 0; i < this.size_of_Un; i++){
			this.Un_as_a_set[i] = temp[i];
		}
		/*
			create subgroups generated by each non-identity element of Un
		*/
		this.subgroups_generated_by_elements = new Subgroup[this.size_of_Un-1];
		for(int i = 0; i < this.subgroups_generated_by_elements.length; i++){
			this.subgroups_generated_by_elements[i] = new Subgroup(this.n, this.Un_as_a_set[i+1]);
		}
		/*
			see if any of the subgroups generated by each element is Un itself
		*/
		for(int i = 0; i < this.subgroups_generated_by_elements.length; i++){
			if(this.subgroups_generated_by_elements[i].get_size_of_subgroup() == this.size_of_Un){
				this.is_cyclic = true;
			}
		}
		/*
			now count the number of distinct subgroups. since the subgroup arrays don't include the subgroup generated by the identity element, we will then start with 1, and count up from there. we will gather these in an array. to create this array we need to initialize the values to -1
		*/
		this.num_distinct_subgroups = 0;
		this.subgroup_generators = new int[this.size_of_Un];		
		for(int i = 0; i < this.subgroup_generators.length; i++){
			this.subgroup_generators[i] = -1;
		}
		this.subgroup_generators[this.num_distinct_subgroups++] = 1;
		for(int i = 0; i < this.subgroups_generated_by_elements.length; i++){
			if(!(is_in(this.subgroups_generated_by_elements[i].get_generator(), subgroup_generators))){
				this.subgroup_generators[this.num_distinct_subgroups++] = this.subgroups_generated_by_elements[i].get_generator();
			}
		}
	}

	public boolean is_in(int number, int[] array_to_search){
		boolean output = false;
		for(int i = 0; i < array_to_search.length; i++){
			if(array_to_search[i] == number){
				output = true;
			}
		}
		return output;
	}

	public int digits_in(int i){
		int count = 0;
		while(i != 0){
			i /= 10;
			count++;
		}
		return count;
	}

	public String empty_cell(int width_of_cell){
		String output = "";
		for(int i = 0; i < width_of_cell; i++){
			output += " ";
		}
		output += "|";
		return output;
	}

	public String pad_on_right(int number, int width_of_cell){
		String output = "";
		output += number;
		for(int i = digits_in(number); i < width_of_cell; i++){
			output += " ";
		}
		output += "|";
		return output;
	}

	public String horiz_line(int width_of_cell, int number_of_cells){
		String output = "";
		for(int cell = 0; cell < number_of_cells; cell++){
			for(int dashes = 0; dashes < width_of_cell; dashes++){
				output += "-";
			}
			output += "|";
		}
		output += "\n";
		return output;
	}

	public String make_table(){
		/*
			set the width of each cell by the max number of digits in the largest number to be displayed in the table (which low-key is in the last index of Un_as_a_set)
		*/
		String output = "";
		int width_of_cell = digits_in(this.Un_as_a_set[this.size_of_Un - 1]);
		/*
			from here, we insert negative rows and columns on the top and bottom of the table, so row 0 describes element 0 of Un_as_a_set's products and so on, though we need to have catches for the spacial cases where we're dealing with negative columns and rows
		*/
		for(int row = -1; row < this.size_of_Un; row++){
			for(int column = -1; column < this.size_of_Un; column++){
				if(row == -1){
					if(column == -1){
						output += empty_cell(width_of_cell);
					}else{
						output += pad_on_right(this.Un_as_a_set[column], width_of_cell);
					}
				}else{
					if(column == -1){
						output += pad_on_right(this.Un_as_a_set[row], width_of_cell);
					}else{
						output += pad_on_right((this.Un_as_a_set[row] * this.Un_as_a_set[column]) % this.n, width_of_cell);
					}
				}
			}
			output += "\n";
			output += horiz_line(width_of_cell, this.size_of_Un+1);
		}
		return output;
	}

	public String get_details(){
		String output = "";
		/*
			concatinate Un as a set
		*/
		output += String.format("U(%d) = { ", this.n);
		for(int i = 0; i < this.size_of_Un; i++){
			output += String.format("%s", this.Un_as_a_set[i]);
			if(i < this.size_of_Un-1){
				output += String.format(", ");
			}
		}
		output += String.format(" }%n");
		/*
			concatinate |U(n)|
		*/
		output += String.format("    |U(%d)| = %d%n", this.n, this.size_of_Un);
		/*
			concatinate each subgroup generated by each non-identity element of Un
		*/
		for(int i = 1; i < this.size_of_Un; i++){
			output += String.format("%s%n", this.subgroups_generated_by_elements[i-1].get_details());
		}
		/*
			concatinate the multiplication table for Un
		*/
		//output += String.format("The Cayley table for U(%d) is as follows:%n%s%n", this.n, make_table());
		/*
			concatinate whether this particular Un is cyclic
		*/
		if(this.is_cyclic){
			output += String.format("U(%d) is cyclic%n%n", this.n);
		}else{
			output += String.format("U(%d) is not cyclic%n%n", this.n);
		}
		/*
			concatinate the number of distinct subgroups
		*/
		output += String.format("U(%d) has %d unique, proper, subgroups, and their generators are as follows:%n", this.n, this.num_distinct_subgroups);
		for(int i = 0; i < this.num_distinct_subgroups; i++){
			output += String.format("<%d>", this.subgroup_generators[i]);
			if(i < this.num_distinct_subgroups - 1){
				output += String.format(", ");
			}
		}
		output += "\n";
		return output;
	}
}